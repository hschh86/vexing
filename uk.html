<!DOCTYPE html>
<html>
 <head>
	<meta charset='utf-8'>
	<title> Union Jack </title>
    <!--
	<link rel="stylesheet" href="">
	<script src=""></script>
    -->
    <script src="scripts/libs/snap/snap.svg-min.js"></script>

    <!-- Temporary style. -->
    <style>
      #main_svg_object {
        border: 1px solid black;
      }
      body {
        font-family: sans-serif;
      }


      /* Mask rules. */
      .solidmask {
        stroke: none;
        fill: white;
      }
    </style>

 </head>
 <body>
 <h1> united kingdom of great britain and northern ireland </h1>
     <div id="svgdiv">
    <svg id="main_svg_object"
         xmlns="http://www.w3.org/2000/svg"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         width="600" height="300" >
   </svg>
 </div>

<h1> Controls go here. </h1>
<ul>
  <li> Size
    <ul>
      <li>Ratio:
        <ul>
          <li>width</li>
          <li>height</li>
        </ul>
      </li>
      <li>unit-scaling</li>
      <li>Display...</li>
    </ul>
  </li>
  <li> Shape
    <ul>
      <li>saltire
        <ul>
          <li>Patrick?</li>
          <li>fim-width</li>
          <li>width</li>
          <li>offset</li>
        </ul>
      </li>
      <li>cross
        <ul>
          <li>fim-width</li>
          <li>width</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>colour
    <ul>
      <li>blue</li>
      <li>red</li>
      <li>white</li>
    </ul>
  </li>
</ul>
   <script>
     var Vexing = (function() {
       'use strict';
       // Declare the stuff we want.
       var mainsvg, flagzone, unionjack;

       // Compartmentalise some functions in an object...
       // Fun With Getters And Setters!
       var f = {
         size: {
           hFly: 30,
           hHoist: 15,
           get fFly(){
             return this.hFly * 2
           },
           set fFly(x){
             this.hFly = x/2
           },
           get fHoist(){
             return this.hHoist * 2
           },
           set fHoist(x){
             this.hHoist = x/2
           }
         },
         saltire: {
           patrick: true,
           backWidth: 6,
           frontWidth: 4,
           offset: 0,
         },
         cross: {
           backWidth: 10,
           frontWidth: 6,
         },
         colour: {
           red: "red",
           blue: "navy",
           white: "white"
         }
       }

       // Now, let's attempt to do some OO.
       // I don't actually know how to do this,
       // but it's worth a shot, hey?



       var SVGNS = "http://www.w3.org/2000/svg";

       var Felement = (function() {
         // A Felement contains an SVG Element. Very basic thing.
         // Creating a Felement also creates an SVG Element.
         function Felement (tag) {
           this.createNode(tag);
           this.children = [];
         }
         var p = Felement.prototype;
         p.constructor = Felement;
         // Is setting the constructor even necessary? I don't know.

         p.createNode = function (tag) {
           // creates a new SVG Element, which can be accessed using this.node
           this.node = document.createElementNS(SVGNS, tag);
         }

         p.append = function (child) {
           // appends another Felement.
           // It might be a good idea to do some sort of
           // child instanceof Felement check here.
           this.node.appendChild(child.node);


           this.children.push(child);
         }

         p.appendTo = function (parent) {
           parent.node.appendChild(this.node);
         }

         p.appendToNode = function (parentnode) {
           parentnode.appendChild(this.node);
         }

         return Felement;
       }());


       var Fshape = (function() {
         function Fshape () {

         };

         var p = Fshape.prototype;


         p.newNode = function (node) {
           if (typeof node === "undefined") {
             node = this.newSVGElement();
           };
           this.node = node;
           //this.el = Snap(node);
           return this;
         };

         p.newSVGElement = function () {
           return document.createElementNS(SVGNS, this.svgtag);
         }

         p.setVal = function (name, value) {
           var attr = this.AttributeMap[name] || name;
           this[name] = value;
           this.node.setAttribute(attr, value);
           return this;
         };

         // this might be better done with the SVG DOM API instead.
         // such as Element.height.baseval.value = x
         // instead of Element.setAttribute("height", x).
         // At least the reading gives you proper numbers.
         // It would require more complex mapping to attributes, though.
         // Maybe one for SVGLength, one for style.color etc?

         p.appendToNode = function (parent) {
           parent.appendChild(this.node);
           return this;
         }

         return Fshape;
       }());

       var Fline = (function() {
         // trying out using iifes to encapsulate.
         function Fline () {
           //Fshape.call(this);
         };

         Fline.prototype = Object.create(Fshape.prototype);
         Fline.prototype.constructor = Fline;


         var p = Fline.prototype;


         // It's possible to do some sort of sub-inheritance
         // I'm not sure if this is a good idea or not.
         // or even if the pseudoclassical way I'm doing this is even
         // good at all. Maybe I should try to do it while only using
         // Object.create and the object property thingies.
         //
         // p.props = Object.create(Fshape.prototype.props)


         p.AttributeMap = {
             "x1": "x1",
             "y1": "y1",
             "x2": "x2",
             "y2": "y2",
             "width": "stroke-width",
             "colour": "stroke"
          };
         p.svgtag = "line";

         p.setStart = function (x1, y1) {
           return this.setVal("x1", x1).setVal("y1", y1);
         }
         p.setEnd = function (x2, y2) {
           return this.setVal("x2", x2).setVal("y2", y2);
         }
         p.setWidth = function (width) {
           return this.setVal("width", width);
         }
         p.setColour = function (colour) {
           return this.setVal("colour", colour);
         }

         return Fline;
       }());

       var Frect = (function() {
         function Frect () {
           //return this;
         };
         Frect.prototype = Object.create(Fshape.prototype);
         var p = Frect.prototype;
         p.constructor = Frect;
         // I suppose var p = Frect.prototype = Object.create(..) also works
         p.AttributeMap = {
             "x": "x",
             "y": "y",
             "width": "width",
             "height": "height",
             "colour": "fill"
          };
         p.svgtag = "rect";

         p.setLocation = function (x, y) {
           return this.setVal("x", x).setVal("y", y);
         }
         p.setSize = function (w, h) {
           return this.setVal("width", w).setVal("height", h);
         }
         p.setColour = function (colour) {
           return this.setVal("colour", colour);
         }

         p.setExtent = function (x1, y1, x2, y2) {
           var xmin = Math.min(x1, x2),
               ymin = Math.min(y1, y2),
               xdif = Math.abs(x1 - x2),
               ydif = Math.abs(y1 - y2);
           return this.setLocation(xmin, ymin).setSize(xdif, ydif);
         }

        return Frect;
       }());


       // Doing things "properly" has never really been my strong point.

       /*
       Rough outline of how this structure works (or doesn't work).
       PRIMITIVE SHAPES. Basically, lines and rectangles. Wrap SVG shapes.
       GRAPHIC ELEMENTS. Represent crosses, saltires etc. Wrap SVG groups.
       FLAG STRUCTURE. Represents the whole flag. Also wraps SVG groups.
           - contains GElements, which countain PShapes.
           GElements can also contain GElements...

           You know what, this doesn't actually make any sense.

       Part III in the thrilling series: Getting Way Ahead Of Myself:
       Using the SVG DOM API itself.

       As I am only manipulating rectangles and polygons,
       it shouldn't be too hard.
       (Famous last words right there.)

       Lengths are represented in the API by SVGLength,
       Points by SVGPoint, which live in SVGPointList.
       There's also SVGTransform and SVGMatrix, and SVGAngle, and
       the ways to style with fill and stroke, which use the style interface
       instead of the SVG one.

       Simply, to set a length, we use <element>.length.baseVal.value
       or .valueInSpecifiedUnits. To change the units there's two methods which
       are used to either change the units, keeping the same actual value
       (5cm = 50mm etc) or just change both in one fell swoop.

       I don't know which one I should use, either setting
       value or valueInSpecifiedUnits. I suppose value corresponds to
       'user coordinate pixels' or something like that.

       Since this is going to be a simple programmatical thing, I think using
       'value' (with implied user units) is the best. I dunno.

       I suppose there could be a function like
       proto.setWidth(w) {
        this.node.width.baseVal.value = w;
     }
     To do it with the DRY principle probably a mixin or something

     lengthChanger (property) {
     return function (x) {
      this.node[property].baseVal.value = x;
   }
   }
   proto.setWidth = lengthChanger('width');



   or maybe with a getsetter
   proto = Object.create(PARENT.prototype, {
   width: {
   // that configurable thing goes here
   set: lengthChanger('width'),
   get: lengthGet('width')
 }
 })

  or maybe with a getsetter mixin
  lengthChangerMixin(obj, prop) {
  Object.defineProperty(obj, prop, {
  // configurable: whatevber
  set: function(x) {this.node[prop].baseVal.value = x},
  get: function() {return this.node[prop].baseVal.value}
}
})
}
lengthChangerMixin(proto, "width")

of course, if you really wanted to take it a step further just store the
actual function itself

SVGLengthPrototype = Object.getPrototypeOf(*any baseval object*)
SVGLengthPrototypeValueDef = Object.getPropertyDescriptor(SVGLengthPrototype, "value")
SVGLengthPrototypeValueDef.set and .get get you the actual functions, now you would
have to bind them to the node on each, like
SVGLengthPrototypeValueDef.set.bind(this.node), on each individual constructor
to make sure the right node is called. Not worth it, actually, what with
inheritance and whatnot. Forget it.









       */



       var initialise = function () {
         // Step 1: Grab some References
         // Grab the mainsvg
         mainsvg = Snap('#main_svg_object');
         // We want some sort of Flag Zone within it...
         // to contain the flag.
         flagzone = mainsvg.svg().attr({id: "flagzone"});

         // Step 2: DRAW THE UNION JACK
         // Within this Flag Zone we want to designate the area for our UJ.
         unionjack = flagzone.svg().attr({
           id: "unionjack",
           // set up the ViewBox so everything works properly!
           viewBox: [-f.size.hFly, -f.size.hHoist,
                      f.size.fFly,  f.size.fHoist]
         });

         // Now, for some Geometry.


         // Basic Cross.
         var basicCross = unionjack.g().toDefs().attr({id: "basicCross"});
         // -- Horizontal line
         basicCross.line(
           -f.size.hFly, 0,
            f.size.hFly, 0
          ).attr({id: "basicHLine"});
         // -- Vertical line
         basicCross.line(
           0, -f.size.hHoist,
           0, f.size.hHoist
          ).attr({id: "basicVLine"});

         // Saltire Bits.
         // -- for now, just ignore the offset entirely.
         // -- let's go down, and to the right.
         var basicSBit = unionjack.line(
           f.saltire.offset, -f.saltire.offset,
           f.size.hFly, f.size.hHoist
         ).toDefs().attr({id: "basicSBit"});



         // How about some boxes?
         var fullMask = unionjack.mask().attr({
           // BUG: You cannot use a mask with an ID set manually.
           //id: "fullMask",
           class: "solidmask"
         })
         var fullBox = fullMask.rect(
           -f.size.hFly, -f.size.hHoist,
            f.size.fFly,  f.size.fHoist
          ).attr({id: "fullBox"});


          var quarterMask = unionjack.mask().attr({
            //id: "quarterMask",
            class: "solidmask",
          });
         var quarterBox = quarterMask.rect(
           0, 0,
           f.size.hFly, f.size.hHoist
         ).attr({id: "quarterBox"});








         // We're also gonna need to do some pinwheels.
         // The offset point: (+f.saltire.offset, -f.saltire.offset)
         // Moves diagonally along the unit grid.

         var hoistPMask = unionjack.mask().attr({
           //id: "hoistPMask",
           class: "solidmask"
         });
         var hoistPinwheel = hoistPMask.polyline(
           0, 0,
           f.saltire.offset, -f.saltire.offset,
           f.size.hFly, f.size.hHoist,
           f.size.hFly, 0
          ).attr({
            id: "hoistPinwheel",
            mask: quarterMask,
          });

        var flyPMask = unionjack.mask().attr({
          //id: "flyPMask",
          class: "solidmask"
        });

         var flyPinwheel = flyPMask.polyline(
           0, 0,
           f.saltire.offset, -f.saltire.offset,
           f.size.hFly, f.size.hHoist,
           0, f.size.hHoist
          ).attr({
            id: "flyPinwheel",
            mask: quarterMask,
          });




         var backSBit = unionjack.use(basicSBit).toDefs().attr({
           id: "backSBit",
           stroke: f.colour.white,
           strokeWidth: f.saltire.backWidth,
           mask: quarterMask
         })

         var frontSBit = unionjack.use(basicSBit).toDefs().attr({
           id: "frontSBit",
           stroke: f.colour.red,
           strokeWidth: f.saltire.frontWidth,
         });



         // For the moment, let's pretend it's 1707.

         // Do Some Art!
         var field = unionjack.use(fullBox).attr({
           id: "field",
           class: "scottishblue backdrop",
           fill: f.colour.blue,

         });

         unionjack.use(backSBit)
         .clone().transform('s-1,1')
        .clone().transform('s-1,-1')
         .clone().transform('s1,-1');

         unionjack.use(frontSBit).attr({mask: hoistPMask})
         .clone().transform('s-1,-1')

         unionjack.use(frontSBit).attr({mask: flyPMask}).transform('s-1,1')
         .clone().transform('s1,-1')


         var backCross = unionjack.use(basicCross).attr({
           id: "fimCross",
           class: "fimbriaton",
           stroke: f.colour.white,
           strokeWidth: f.cross.backWidth
         })
         var frontCross = unionjack.use(basicCross).attr({
           id: "mainCross",
           class: "jackred",
           stroke: f.colour.red,
           strokeWidth: f.cross.frontWidth
         })

       }

       return {
         initialise: initialise,
         Fline: Fline,
       }
     }());

     window.onload = function () {
       Vexing.initialise();
     }


   </script>

 </body>
</html>
