<!DOCTYPE html>
<html>
 <head>
	<meta charset='utf-8'>
	<title> Union Jack </title>
    <!--
	<link rel="stylesheet" href="">
	<script src=""></script>
    -->
    <script src="scripts/libs/snap/snap.svg-min.js"></script>

    <!-- Temporary style. -->
    <style>
      #main_svg_object {
        border: 1px solid black;
      }
      body {
        font-family: sans-serif;
      }


      /* Mask rules. */
      .solidmask {
        stroke: none;
        fill: white;
      }
    </style>

 </head>
 <body>
 <h1> united kingdom of great britain and northern ireland </h1>
     <div id="svgdiv">
    <svg id="main_svg_object"
         xmlns="http://www.w3.org/2000/svg"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         width="600" height="300" >
   </svg>
 </div>

<h1> Controls go here. </h1>
<ul>
  <li> Size
    <ul>
      <li>Ratio:
        <ul>
          <li>width</li>
          <li>height</li>
        </ul>
      </li>
      <li>unit-scaling</li>
      <li>Display...</li>
    </ul>
  </li>
  <li> Shape
    <ul>
      <li>saltire
        <ul>
          <li>Patrick?</li>
          <li>fim-width</li>
          <li>width</li>
          <li>offset</li>
        </ul>
      </li>
      <li>cross
        <ul>
          <li>fim-width</li>
          <li>width</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>colour
    <ul>
      <li>blue</li>
      <li>red</li>
      <li>white</li>
    </ul>
  </li>
</ul>
   <script>
     var Vexing = (function() {
       'use strict';
       // Declare the stuff we want.
       var mainsvg, flagzone, unionjack;

       // Compartmentalise some functions in an object...
       // Fun With Getters And Setters!
       var f = {
         size: {
           hFly: 30,
           hHoist: 15,
           get fFly(){
             return this.hFly * 2
           },
           set fFly(x){
             this.hFly = x/2
           },
           get fHoist(){
             return this.hHoist * 2
           },
           set fHoist(x){
             this.hHoist = x/2
           }
         },
         saltire: {
           patrick: true,
           backWidth: 6,
           frontWidth: 4,
           offset: 0,
         },
         cross: {
           backWidth: 10,
           frontWidth: 6,
         },
         colour: {
           red: "red",
           blue: "navy",
           white: "white"
         }
       }

       // Now, let's attempt to do some OO.
       // I don't actually know how to do this,
       // but it's worth a shot, hey?



       var SVGNS = "http://www.w3.org/2000/svg";

       var Felement = (function() {
         // A Felement contains an SVG Element. Very basic thing.
         // Creating a Felement also creates an SVG Element.
         function Felement (tag) {
           this.createNode(tag);
           this.children = [];
         }
         var p = Felement.prototype;
         p.constructor = Felement;
         // Is setting the constructor even necessary? I don't know.

         p.createNode = function (tag) {
           // creates a new SVG Element, which can be accessed using this.node
           this.node = document.createElementNS(SVGNS, tag);
         }

         p.append = function (child) {
           // appends another Felement.
           // It might be a good idea to do some sort of
           // child instanceof Felement check here.
           this.node.appendChild(child.node);


           this.children.push(child);
         }

         p.appendTo = function (parent) {
           parent.node.appendChild(this.node);
         }

         p.appendToNode = function (parentnode) {
           parentnode.appendChild(this.node);
         }

         p.setAttribute = function (name, value) {
           // a convenience
           this.node.setAttribute(name, value);
           return this;
         }

         return Felement;
       }());

       var FDescriptor = (function() {

         // This part is totally unnecessary, but then again, so is this whole project.

         // I've gone too deep.

         var descriptorProto = {
           configurable: true,
           enumerable: false
         }

         var lengthFactory = function (property) {
           return {
             get: function () { return this.node[property].baseVal.value },
             set: function (x) { return this.node[property].baseVal.value = x }
           )
         }

         var styleFactory = function (property) {
           return {
             get: function () { return this.node.style[property] },
             set: function (x) { return this.node.style[property] = x }
           }
         }

         var attrFactory = function (property) {
           return {
             get: function () { return this.node.getAttribute(property) },
             set: function (x) { return this.node.setAttribute(property, x)}
           }
         }

         var makeDescriptor = function (accessor, coercers) {
           var descriptor = Object.create(descriptorProto);
           descriptor.get = accessor.get;
           descriptor.set = accessor.set;
           if (coercers) {
             if (coercers.get) {
               descriptor.get = function () {
                 return coercers.get(accessor.get.call(this));
               }
             };
             if (coercers.set) {
               descriptor.set = function (x) {
                 return accessor.set.call(this, coercers.set(x));
               }
             };
           };
           return descriptor;
         }

         var descriptorMaker = function (factory) {
           return (function (property, coercers) {
             return makeDescriptor(factory(property), coercers);
           });
         }



         return {
           length: descriptorMaker(lengthFactory),
           style: descriptorMaker(styleFactory),
           attribute: descriptorMaker(attrFactory)
         }
       }());


       var Fshape = (function() {
         function Fshape (tag) {
           Felement.call(this, tag);
         };
         // extends Felement

         var p = Fshape.prototype = Object.create(Felement.prototype);


         return Fshape;
       }());

       var Fline = (function() {
         function Fline () {
           // tag = 'line'
           Fshape.call(this, "line");
         };
         // extends Fshape
         var p = Fline.prototype = Object.create(Fshape.prototype, {
           x1: FDescriptor.length('x1'),
           x2: FDescriptor.length('x2'),
           y1: FDescriptor.length('y1'),
           y2: FDescriptor.length('y2'),
           colour: FDescriptor.style('stroke'),
           width: FDescriptor.style('strokeWidth', {get: Number, set: Number})
         });

         p.setStart = function (x, y) {
           this.x1 = x;
           this.y1 = y;
           return this;
         }

         p.setEnd = function (x, y) {
           this.x2 = x;
           this.y2 = y;
           return this;
         }


         return Fline;
       }());

       var Frect = (function() {
         function Frect () {
           // tag = 'rect'
           Fshape.call(this, 'rect');
         };
         // Extends Fshape
         var p = Frect.prototype = Object.create(Fshape.prototype , {
           x: FDescriptor.length('x'),
           y: FDescriptor.length('y'),
           width: FDescriptor.length('width'),
           height: FDescriptor.length('height'),
           colour: FDescriptor.style('fill')
         });


         p.setLocation = function (x, y) {
           this.x = x;
           this.y = y;
           return this;
         }

         p.setSize = function (width, height) {
           this.width = width;
           this.height = height;
           return this;
         }

         p.setExtent = function (x1, y1, x2, y2) {
           var xmin = Math.min(x1, x2),
               ymin = Math.min(y1, y2),
               xdif = Math.abs(x1 - x2),
               ydif = Math.abs(y1 - y2);
           return this.setLocation(xmin, ymin).setSize(xdif, ydif);
         }

        return Frect;
       }());


       // Doing things "properly" has never really been my strong point.

       /*
  Rough outline of how this structure works (or doesn't work).
  PRIMITIVE SHAPES. Basically, lines and rectangles. Wrap SVG shapes.
  GRAPHIC ELEMENTS. Represent crosses, saltires etc. Wrap SVG groups.
  FLAG STRUCTURE. Represents the whole flag. Also wraps SVG groups.
  - contains GElements, which countain PShapes.
    GElements can also contain GElements...

  You know what, this doesn't actually make any sense.

  Part III in the thrilling series: Getting Way Ahead Of Myself:
  Using the SVG DOM API itself.

  As I am only manipulating rectangles and polygons,
  it shouldn't be too hard.
  (Famous last words right there.)

  Lengths are represented in the API by SVGLength,
  Points by SVGPoint, which live in SVGPointList.
  There's also SVGTransform and SVGMatrix, and SVGAngle, and
  the ways to style with fill and stroke, which use the style interface
  instead of the SVG one.

  Simply, to set a length, we use <element>.length.baseVal.value
  or .valueInSpecifiedUnits. To change the units there's two methods which
  are used to either change the units, keeping the same actual value
  (5cm = 50mm etc) or just change both in one fell swoop.

  I don't know which one I should use, either setting
  value or valueInSpecifiedUnits. I suppose value corresponds to
  'user coordinate pixels' or something like that.

  Since this is going to be a simple programmatical thing, I think using
  'value' (with implied user units) is the best. I dunno.


  Now, on to colour, or to be precise, paint.
  In SVG, the paint can be defined as attributes like fill='blue',
  inline styles like style="fill:'blue';", and proper CSS stylesheets which can
  reside inside the SVG element, on the HTML page, inline or linked.
  I believe attributes > inline styles > stylesheets when it comes to priority.
  Thus, there are different ways to programatically set the colour.
  Setting the attributes is done via document.setAttribute('fill', col) etc.
  Setting via the inline style is done by accessing (node).style.fill = col,
  or (node).style.setProperty('fill', col).
  Changing a stylesheet is a bit more complicated but can be done by accessing
  the stylesheet element and then getting the actual rule that is applied,
  which lives in (stylesheet node).sheet.cssRules. Once you have that then you
  can use (cssRule).style and so on.

  For the sake of simplicity, let's use the inline style version, so we don't
  have to mess around too much with setting attributes.

 */



       var initialise = function () {
         // Step 1: Grab some References
         // Grab the mainsvg
         mainsvg = Snap('#main_svg_object');
         // We want some sort of Flag Zone within it...
         // to contain the flag.
         flagzone = mainsvg.svg().attr({id: "flagzone"});

         // Step 2: DRAW THE UNION JACK
         // Within this Flag Zone we want to designate the area for our UJ.
         unionjack = flagzone.svg().attr({
           id: "unionjack",
           // set up the ViewBox so everything works properly!
           viewBox: [-f.size.hFly, -f.size.hHoist,
                      f.size.fFly,  f.size.fHoist]
         });

         // Now, for some Geometry.


         // Basic Cross.
         var basicCross = unionjack.g().toDefs().attr({id: "basicCross"});
         // -- Horizontal line
         basicCross.line(
           -f.size.hFly, 0,
            f.size.hFly, 0
          ).attr({id: "basicHLine"});
         // -- Vertical line
         basicCross.line(
           0, -f.size.hHoist,
           0, f.size.hHoist
          ).attr({id: "basicVLine"});

         // Saltire Bits.
         // -- for now, just ignore the offset entirely.
         // -- let's go down, and to the right.
         var basicSBit = unionjack.line(
           f.saltire.offset, -f.saltire.offset,
           f.size.hFly, f.size.hHoist
         ).toDefs().attr({id: "basicSBit"});



         // How about some boxes?
         var fullMask = unionjack.mask().attr({
           // BUG: You cannot use a mask with an ID set manually.
           //id: "fullMask",
           class: "solidmask"
         })
         var fullBox = fullMask.rect(
           -f.size.hFly, -f.size.hHoist,
            f.size.fFly,  f.size.fHoist
          ).attr({id: "fullBox"});


          var quarterMask = unionjack.mask().attr({
            //id: "quarterMask",
            class: "solidmask",
          });
         var quarterBox = quarterMask.rect(
           0, 0,
           f.size.hFly, f.size.hHoist
         ).attr({id: "quarterBox"});








         // We're also gonna need to do some pinwheels.
         // The offset point: (+f.saltire.offset, -f.saltire.offset)
         // Moves diagonally along the unit grid.

         var hoistPMask = unionjack.mask().attr({
           //id: "hoistPMask",
           class: "solidmask"
         });
         var hoistPinwheel = hoistPMask.polyline(
           0, 0,
           f.saltire.offset, -f.saltire.offset,
           f.size.hFly, f.size.hHoist,
           f.size.hFly, 0
          ).attr({
            id: "hoistPinwheel",
            mask: quarterMask,
          });

        var flyPMask = unionjack.mask().attr({
          //id: "flyPMask",
          class: "solidmask"
        });

         var flyPinwheel = flyPMask.polyline(
           0, 0,
           f.saltire.offset, -f.saltire.offset,
           f.size.hFly, f.size.hHoist,
           0, f.size.hHoist
          ).attr({
            id: "flyPinwheel",
            mask: quarterMask,
          });




         var backSBit = unionjack.use(basicSBit).toDefs().attr({
           id: "backSBit",
           stroke: f.colour.white,
           strokeWidth: f.saltire.backWidth,
           mask: quarterMask
         })

         var frontSBit = unionjack.use(basicSBit).toDefs().attr({
           id: "frontSBit",
           stroke: f.colour.red,
           strokeWidth: f.saltire.frontWidth,
         });



         // For the moment, let's pretend it's 1707.

         // Do Some Art!
         var field = unionjack.use(fullBox).attr({
           id: "field",
           class: "scottishblue backdrop",
           fill: f.colour.blue,

         });

         unionjack.use(backSBit)
         .clone().transform('s-1,1')
        .clone().transform('s-1,-1')
         .clone().transform('s1,-1');

         unionjack.use(frontSBit).attr({mask: hoistPMask})
         .clone().transform('s-1,-1')

         unionjack.use(frontSBit).attr({mask: flyPMask}).transform('s-1,1')
         .clone().transform('s1,-1')


         var backCross = unionjack.use(basicCross).attr({
           id: "fimCross",
           class: "fimbriaton",
           stroke: f.colour.white,
           strokeWidth: f.cross.backWidth
         })
         var frontCross = unionjack.use(basicCross).attr({
           id: "mainCross",
           class: "jackred",
           stroke: f.colour.red,
           strokeWidth: f.cross.frontWidth
         })

       }

       return {
         initialise: initialise,
         Frect: Frect,
         Fline: Fline
       }
     }());

     window.onload = function () {
       Vexing.initialise();
     }


   </script>

 </body>
</html>
